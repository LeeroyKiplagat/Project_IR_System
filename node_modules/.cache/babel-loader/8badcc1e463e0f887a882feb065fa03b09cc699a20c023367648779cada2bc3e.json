{"ast":null,"code":"/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { createContext, useMemo, useCallback } from 'react';\nimport { useDeepEqual } from '../../../services';\nimport { defaultComparator } from './data_grid_schema';\nexport var DataGridSortedContext = /*#__PURE__*/createContext({\n  sortedRowMap: [],\n  getCorrectRowIndex: function getCorrectRowIndex(number) {\n    return number;\n  }\n});\nexport var useSorting = function useSorting(_ref) {\n  var sorting = _ref.sorting,\n    inMemory = _ref.inMemory,\n    inMemoryValues = _ref.inMemoryValues,\n    schema = _ref.schema,\n    schemaDetectors = _ref.schemaDetectors,\n    startRow = _ref.startRow;\n  var sortingColumns = useDeepEqual(sorting === null || sorting === void 0 ? void 0 : sorting.columns);\n  var sortedWrappedValues = useMemo(function () {\n    if ((inMemory === null || inMemory === void 0 ? void 0 : inMemory.level) === 'sorting' && sortingColumns != null && sortingColumns.length > 0) {\n      var inMemoryRowIndices = Object.keys(inMemoryValues);\n      return inMemoryRowIndices.map(function (row, index) {\n        return {\n          index: index,\n          values: inMemoryValues[row]\n        };\n      }).sort(function (a, b) {\n        for (var i = 0; i < sortingColumns.length; i++) {\n          var column = sortingColumns[i];\n          var aValue = a.values[column.id];\n          var bValue = b.values[column.id];\n\n          // get the comparator, based on schema\n          var comparator = defaultComparator;\n          if (schema.hasOwnProperty(column.id)) {\n            var columnType = schema[column.id].columnType;\n            for (var _i = 0; _i < schemaDetectors.length; _i++) {\n              var detector = schemaDetectors[_i];\n              if (detector.type === columnType && detector.hasOwnProperty('comparator')) {\n                comparator = detector.comparator;\n              }\n            }\n          }\n          var result = comparator(aValue, bValue, column.direction, {\n            aIndex: a.index,\n            bIndex: b.index\n          });\n          // only return if the columns are unequal, otherwise allow the next sort-by column to run\n          if (result !== 0) return result;\n        }\n        return 0;\n      });\n    }\n  }, [inMemory === null || inMemory === void 0 ? void 0 : inMemory.level, inMemoryValues, sortingColumns, schema, schemaDetectors]);\n  var sortedRowMap = useMemo(function () {\n    if ((inMemory === null || inMemory === void 0 ? void 0 : inMemory.level) === 'sorting' && sortingColumns != null && sortingColumns.length > 0 && sortedWrappedValues != null) {\n      return sortedWrappedValues.map(function (row) {\n        return row.index;\n      });\n    } else {\n      return [];\n    }\n  }, [inMemory === null || inMemory === void 0 ? void 0 : inMemory.level, sortingColumns, sortedWrappedValues]);\n\n  // Given a visible row index, obtain the unpaginated & unsorted\n  // row index from the passed cell data\n  var getCorrectRowIndex = useCallback(function (visibleRowIndex) {\n    var isPaginated = visibleRowIndex - startRow < 0;\n    var unpaginatedRowIndex = isPaginated ? visibleRowIndex + startRow : visibleRowIndex;\n    var unsortedRowIndex = unpaginatedRowIndex in sortedRowMap ? sortedRowMap[unpaginatedRowIndex] : unpaginatedRowIndex;\n    return unsortedRowIndex;\n  }, [startRow, sortedRowMap]);\n  return useMemo(function () {\n    return {\n      sortedRowMap: sortedRowMap,\n      getCorrectRowIndex: getCorrectRowIndex\n    };\n  }, [sortedRowMap, getCorrectRowIndex]);\n};","map":{"version":3,"names":["createContext","useMemo","useCallback","useDeepEqual","defaultComparator","DataGridSortedContext","sortedRowMap","getCorrectRowIndex","number","useSorting","_ref","sorting","inMemory","inMemoryValues","schema","schemaDetectors","startRow","sortingColumns","columns","sortedWrappedValues","level","length","inMemoryRowIndices","Object","keys","map","row","index","values","sort","a","b","i","column","aValue","id","bValue","comparator","hasOwnProperty","columnType","_i","detector","type","result","direction","aIndex","bIndex","visibleRowIndex","isPaginated","unpaginatedRowIndex","unsortedRowIndex"],"sources":["D:/Masters/Advance Database Systems/Labs/Project_IR_System/node_modules/@elastic/eui/es/components/datagrid/utils/sorting.js"],"sourcesContent":["/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0 and the Server Side Public License, v 1; you may not use this file except\n * in compliance with, at your election, the Elastic License 2.0 or the Server\n * Side Public License, v 1.\n */\n\nimport { createContext, useMemo, useCallback } from 'react';\nimport { useDeepEqual } from '../../../services';\nimport { defaultComparator } from './data_grid_schema';\nexport var DataGridSortedContext = /*#__PURE__*/createContext({\n  sortedRowMap: [],\n  getCorrectRowIndex: function getCorrectRowIndex(number) {\n    return number;\n  }\n});\nexport var useSorting = function useSorting(_ref) {\n  var sorting = _ref.sorting,\n    inMemory = _ref.inMemory,\n    inMemoryValues = _ref.inMemoryValues,\n    schema = _ref.schema,\n    schemaDetectors = _ref.schemaDetectors,\n    startRow = _ref.startRow;\n  var sortingColumns = useDeepEqual(sorting === null || sorting === void 0 ? void 0 : sorting.columns);\n  var sortedWrappedValues = useMemo(function () {\n    if ((inMemory === null || inMemory === void 0 ? void 0 : inMemory.level) === 'sorting' && sortingColumns != null && sortingColumns.length > 0) {\n      var inMemoryRowIndices = Object.keys(inMemoryValues);\n      return inMemoryRowIndices.map(function (row, index) {\n        return {\n          index: index,\n          values: inMemoryValues[row]\n        };\n      }).sort(function (a, b) {\n        for (var i = 0; i < sortingColumns.length; i++) {\n          var column = sortingColumns[i];\n          var aValue = a.values[column.id];\n          var bValue = b.values[column.id];\n\n          // get the comparator, based on schema\n          var comparator = defaultComparator;\n          if (schema.hasOwnProperty(column.id)) {\n            var columnType = schema[column.id].columnType;\n            for (var _i = 0; _i < schemaDetectors.length; _i++) {\n              var detector = schemaDetectors[_i];\n              if (detector.type === columnType && detector.hasOwnProperty('comparator')) {\n                comparator = detector.comparator;\n              }\n            }\n          }\n          var result = comparator(aValue, bValue, column.direction, {\n            aIndex: a.index,\n            bIndex: b.index\n          });\n          // only return if the columns are unequal, otherwise allow the next sort-by column to run\n          if (result !== 0) return result;\n        }\n        return 0;\n      });\n    }\n  }, [inMemory === null || inMemory === void 0 ? void 0 : inMemory.level, inMemoryValues, sortingColumns, schema, schemaDetectors]);\n  var sortedRowMap = useMemo(function () {\n    if ((inMemory === null || inMemory === void 0 ? void 0 : inMemory.level) === 'sorting' && sortingColumns != null && sortingColumns.length > 0 && sortedWrappedValues != null) {\n      return sortedWrappedValues.map(function (row) {\n        return row.index;\n      });\n    } else {\n      return [];\n    }\n  }, [inMemory === null || inMemory === void 0 ? void 0 : inMemory.level, sortingColumns, sortedWrappedValues]);\n\n  // Given a visible row index, obtain the unpaginated & unsorted\n  // row index from the passed cell data\n  var getCorrectRowIndex = useCallback(function (visibleRowIndex) {\n    var isPaginated = visibleRowIndex - startRow < 0;\n    var unpaginatedRowIndex = isPaginated ? visibleRowIndex + startRow : visibleRowIndex;\n    var unsortedRowIndex = unpaginatedRowIndex in sortedRowMap ? sortedRowMap[unpaginatedRowIndex] : unpaginatedRowIndex;\n    return unsortedRowIndex;\n  }, [startRow, sortedRowMap]);\n  return useMemo(function () {\n    return {\n      sortedRowMap: sortedRowMap,\n      getCorrectRowIndex: getCorrectRowIndex\n    };\n  }, [sortedRowMap, getCorrectRowIndex]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}